[{
    "title": "Practical Cue Example, Produce YAML Config from Go Types",
    "date": "",
    "description": "",
    "body": "I recently had to spend some time to learn Cue and felt the examples/tutorials were a bit lacking and the paradigm shift to the entire language sort of messed with my head and some things Cue does were a bit foreign to me. To get started, note that the two places I spent all of my time to get this information came from their main docs and a community Cuetorials site. This will be a tutorial on how you can use Cue to generate two different YAML documents using Cue all starting with Go types to generate Cue files.\nAs Cue changes this could become out of date, this was all done using Cue v0.4.1. All code for this tutorial can be found in this github repository.\nPrerequisites You\u0026rsquo;ll need to install Cue and I recommend you get some basic understanding of the cli commands as there is some power there for your project. I also recommend you get used to modules and the mod command and the directory structure it will create for you. Note the Cue takes a lot of it\u0026rsquo;s packaging and generating inspiration from Go itself so if you\u0026rsquo;ve already done some of this in Go you may already recognize some of these features.\nGo Types to Config YAML Here is a simple scenario we will use to setup this example, we are building a server daemon in Go with a --config flag which is a file path to a YAML configuration document for database drive application with host/port configurations along with a worker pool setting for processing a work queue.\nSample Config:\napp: host: mydomain.com post: 443 workers: 2 db-dsn: root:test@tcp(mysql.domain.com:3306)/test?charset=utf8\u0026amp;parseTime=True\u0026amp;loc=Local This idea is actually pretty simple from Cue\u0026rsquo;s perspective if you write this up by hand but what makes your life easier is if the Go types generate your Cue files so you can import the types into your app and consume your generated config file via unmarshalling.\nSetting Up the Cue Module To get this project setup you\u0026rsquo;ll probably want to use a sub-directory in your project and intialize it as a cue module and place a go file with some types at the root.\n$ cd config $ cue init mod github.com/username/project/config And put your types into the types.go file\npackage config type Config struct { App App `json:\u0026#34;app\u0026#34;` } type App struct { Host string `json:\u0026#34;host\u0026#34;` Port int `json:\u0026#34;port\u0026#34;` Workers int `json:\u0026#34;workers\u0026#34;` DSN string `json:\u0026#34;dsn\u0026#34;` } Your directory structure will look like the following:\n./demo/config$ tree . ├── cue.mod │ ├── module.cue │ ├── pkg │ └── usr └── types.go Now generate your Cue files from the go types\u0026hellip;\ncue get go . Which will create a gen directory with some pathing to a types_go_gen.cue file which contains the following.\n// Code generated by cue get go. DO NOT EDIT. //cue:generate cue get go github.com/luthermonson/tutorials-2022-01-cue/config package config #Config: { app: #App @go(App) } #App: { host: string @go(Host) port: int @go(Port) workers: int @go(Workers) dsn: string @go(DSN) } Now let\u0026rsquo;s use this newly generated file in a super basic cue file to generate our sample YAML document.\npackage config import \u0026quot;github.com/luthermonson/tutorials-2022-01-cue/config\u0026quot; #config: config.#Config \u0026amp; { app: config.#App \u0026amp; { host: \u0026quot;mydomain.com\u0026quot; port: 443 workers: 2 dsn: \u0026quot;root:test@tcp(mysql.domain.com:3306)/test?charset=utf8\u0026amp;parseTime=True\u0026amp;loc=Local\u0026quot; } } #config I recommend you put this cue file in a sub-directory like ./config/cue so you can do something like this\u0026hellip;\n$ cd ./config $ cue export ./cue --out yaml app: host: mydomain.com port: 443 workers: 2 dsn: root:test@tcp(mysql.domain.com:3306)/test?charset=utf8\u0026amp;parseTime=True\u0026amp;loc=Local Using Tags in Cue for Better Config Files Tags are a construct in Cue to let you pass in variables at call time so let\u0026rsquo;s change our Cue file to use tags and consume some environment files based on tag to generate two YAML files. Change the main.cue file to set host/workers/dsn as a variable\u0026hellip;\npackage config import \u0026quot;github.com/luthermonson/tutorials-2022-01-cue/config\u0026quot; #config: config.#Config \u0026amp; { app: config.#App \u0026amp; { host: #host port: 443 workers: #workers dsn: #dsn } } #config add prod.cue\n@if(prod) package config #host: \u0026quot;mydomain.com\u0026quot; #workers: 16 #dsn: \u0026quot;root:prod@tcp(mysql-prod.domain.com:3306)/test?charset=utf8\u0026amp;parseTime=True\u0026amp;loc=Local\u0026quot; add qa.cue\n@if(qa) package config #host: \u0026quot;qa.mydomain.com\u0026quot; #workers: 1 #dsn: \u0026quot;root:qa@tcp(mysql-qa.domain.com:3306)/test?charset=utf8\u0026amp;parseTime=True\u0026amp;loc=Local\u0026quot; Now when you run cue export pass a -t qa or -t prod. The @if() at the top of the file will check if the tags are set and only include those files if the tag was passed. This is a different pattern than say only evaluating certain cue files like cue eval main.cue prod.cue and cue eval main.cue qa.cue which is a pattern outlined by this tutorial. I like the benefits of evaluating cue on a directory of files and passing tags at call time instead of having to figure out which files within the directory need evaluating.\n$ cue export ./cue -t prod --out yaml app: host: mydomain.com port: 443 workers: 16 dsn: root:prod@tcp(mysql-prod.domain.com:3306)/test?charset=utf8\u0026amp;parseTime=True\u0026amp;loc=Local $ cue export ./cue -t qa --out yaml app: host: qa.mydomain.com port: 443 workers: 1 dsn: root:qa@tcp(mysql-qa.domain.com:3306)/test?charset=utf8\u0026amp;parseTime=True\u0026amp;loc=Local Conclusion Please checkout the code for this tutorial on the github repository. This was ultimately a very basic interpretation of the Cue language itself but gives you some ideas for structuring your Cue modules. The language is far more feature rich than this tutorial gives it credit and I will likely do followup blog post on the language itself after and using it to validate your configuration files before they ever hit your application runtime.\n",
    "ref": "/blog/2022/01/practical-cue-example/"
  },{
    "title": "Free Blog Hosting Using Hugo + Github Pages",
    "date": "",
    "description": "Upgrade your Personal Blog Game with Apex Records for No Cost",
    "body": "Since I just rode this merry-go-round here is a quick overview of how you can achieve a professional looking personal blog with custom DNS with minimal effort at no cost and completely run out of a single Github Repository.\nPrerequisites You\u0026rsquo;ll need to do your own homework on how to use Hugo and you should have a Github account and have a decent understanding of using git and getting changes committed and pushed to a repo. You should also have a domain and know how to do some basic DNS changes. Note that the only thing you likely can\u0026rsquo;t get for free is a domain name as there are registration costs through registrars but, you can get introductory $0.99USD domains for the first year if you shop around and don\u0026rsquo;t care the TLD you end up with. For reference, luth.io cost me $30/year to register with CloudFlare.\nDNS Do this part first\u0026hellip; it can take a while to propagate depending on your provider and it will just make your life easier getting it out of the way. What you are trying to do is use Github Pages with an Apex record for your domain. This will let something like https://luth.io be the place where people find your blog. Apex record support for a hosting service will let you bypass using subdomains like https://blog.luth.io which are called CNAMEs in DNS terms. You\u0026rsquo;re looking for A, ALIAS or ANAME records which when pointed at the root of your domain need to be an IP address.\nThis requires Github Pages to support Apex records and provide IP addresses to point your DNS too. This was easily found as there is an entire write-up available from Github Pages help documentation. Following the advice from the article you will need to configure 4 A records and 4 AAAA records and for validation with Github you should add a CNAME for www pointed to your Github Pages username DNS e.g. luthermonson.github.io.\n# A Records 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 # AAAA Records 2606:50c0:8000::153 2606:50c0:8001::153 2606:50c0:8002::153 2606:50c0:8003::153 # CNAME www \u0026lt;githubusername\u0026gt;.github.io When configured through Cloudflare my DNS entries looked like the following, note that skipping the proxy and doing a grey cloud \u0026ldquo;DNS Only\u0026rdquo; was intentional as the proxy will with SSL will cause an infinite redirect loop and Github takes care of SSL for you.\nVerifying your Domain with Github You will need to add your domain to Github and add a DNS TXT record to be able to add it to a repository later. Go to your Github Pages settings for your account (not repository) and Click \u0026ldquo;Add a Domain\u0026rdquo; and follow the instructions by typing your domain, clicking next and getting the DNS TXT records to validate your Domain with Github Pages.\nGrab the details from the Verification Step, add the TXT record to your DNS Provider and then click Verify.\nGithub Repository You will need a Github Repository to house your Hugo blog and all the content, this will be where you serve your pages. Play with Hugo and create your blog, pick a theme and get used to the Huge tool chain. Hugo will create a directory structure, by default when you run the hugo cli command it will generate your blog and place all contents in the ./public directory. Github Pages can NOT serve from anything other than the root ./ and the subdirectory ./docs and for our purposes to serve from one Github Repository we will use ./docs. To fix Hugo to publish to ./docs you can simply add to the config.toml a config line of publishDir = \u0026quot;docs\u0026quot;. When you now run hugo cli it will generate all files to the ./docs directory and prime your repository for serving via Github Pages.\nTo get Github Pages to serve the contents of your Blog with your domain you will need to configure the Pages settings for the repository. Check all your code into a branch and configure your Pages settings like the following. Summary If you configure your DNS properly and use the free Github Pages service you can easily host your personal blog at no cost on your own personal vanity domain name from a single Github Repository. Configure Hugo to use the ./docs directory to adhere to Pages standards then you\u0026rsquo;ll be able to effortlessly set up your Blog. Go henceforth and buy up some novelty domain names and get to blogging!\nLinks  Hugo Cloudflare Free DNS Service Github Github Pages  ",
    "ref": "/blog/2022/01/free-personal-blog-hugo-github-pages/"
  },{
    "title": "Introduction",
    "date": "",
    "description": "",
    "body": "Getting a blog up and running to get some of the thoughts out of my head and into a markdown file. For reference on who I am please check out the about section and stay tuned for more content related to what it is I do everyday.\n",
    "ref": "/blog/introduction/"
  },{
    "title": "About the Blogger",
    "date": "",
    "description": "",
    "body": "Originally born and raised in the Midwest, Luther moved to the expansive deserts of the American Southwest after receiving a Bachelor of the Arts in Computer Science from Gustavus Adolphus College in Southern Minnesota. After moving to Arizona, Luther spent his career building web APIs and utilities for various industries in PHP and NodeJS before migrating to Open Source DevOps tooling using Containers and Virtualization.\nLuther is an Open Source developer mostly writing Go and working in the Kubernetes space by way of his employer SUSE and their Multi-Cluster Management tool Rancher. As the Team Lead for the Windows on Rancher he has spent time specializing in Kubernetes working on alternative operating systems and architectures including arm64 and s390x. Working in this unique space and working from home full time has made him a home lab aficionado and consumer of Proxmox VE.\nContributions to the Rancher and open source:\n vSphere Node Driver Rancher Machine Flannel RKE1 and RKE2 govmomi  Personal Projects:\n goodhosts go-proxmox quiso  ",
    "ref": "/about/"
  }]
